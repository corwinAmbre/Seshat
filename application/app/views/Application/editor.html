#{extends 'main.html' /}
#{set 'title'}&{'editor.title'}#{/set}

<div id="editor" class="flex-container">
	<div id="editor_content" class="flex-item-fluid" spellcheck="true">
		<div class="chapter" v-for="chapter in chapters" id="chapter_{{chapter.number}}">
			<h3 class="lobster txtcenter w100">
				<span class="content">&{'editor.chapter'} {{chapter.number}}</span><span class="buttons">
					<i class="fa fa-trash-o button" v-on:click="removeChapter(chapter.number)" title="&{'editor.icons.deletechapter'}"></i>
				</span>
			</h3>
			<input class="txtcenter w100 chapter_title" v-model="chapter.title" placeholder="&{'editor.placeholders.chaptertitle'}"/>
			<div contenteditable="true" class="scene" v-for="scene in chapter.content" id="chapter_{{chapter.number}}_scene_{{$index}}" v-on:keyup="contentUpdate(chapter.number, $index, $event)" v-on:blur="contentUpdate(chapter.number, $index, $event)" v-on:paste="contentUpdate(chapter.number, $index, $event)" v-on:delete="contentUpdate(chapter.number, $index, $event)" v-on:focus="contentUpdate(chapter.number, $index, $event)">{{{* scene.content}}}</div>
			<div class="txtright addScene"><i class="fa fa-plus-circle button" title="&{'editor.icons.addscene'}" v-on:click="addScene(chapter.number)" role="button" tabindex="0" v-on:keydown.enter="addScene(chapter.number)" aria-label="&{'editor.icons.addscene'}"></i></div>
		</div>
		<div class="txtright addChapter"><i class="fa fa-plus-circle button" title="&{'editor.icons.addchapter'}" v-on:click="addChapter()" role="button" tabindex="0" v-on:keydown.enter="addChapter()" aria-label="&{'editor.icons.addchapter'}"></i></div>
	</div>
	<nav id="editor_nav" class="prs">
		<div class="center">
			<i class="fa fa-floppy-o button" title="&{'editor.icons.savetoserver'}" v-on:click="pushToServer()" role="button" tabindex="0" v-on:keydown.enter="pushToServer()" aria-label="&{'editor.icons.savetoserver'}"></i>
		</div>
		<div class="txtright">
			<i class="fa fa-book button" title="&{'editor.icons.getepub'}" v-on:click="getEpub()" role="button" tabindex="0" v-on:keydown.enter="getEpub()" aria-label="&{'editor.icons.getepub'}">			</i>
		</div>
		<!--div class="chapter_list">
			&{'editor.chapters'}
			<ul class="chapter_list">
				<li v-for="chapter in chapters" class="chapter_list">
					<span v-on:click="goTo(chapter.number)">&{'editor.chapter'} {{chapter.number}} - {{chapter.getWords()}} &{'editor.words'}</span>
				</li>
			</ul>
		</div-->
	</nav>
	<div class="footer">
		&{'editor.wordcount'} {{$data.getWords()}}
	</div>
	<a id="download-epub" style="display:none" aria-hidden="true">&{'editor.icons.getepub'}</a>
</div>
<script type="text/javascript">
	zip.workerScriptsPath = "/public/js/";

	var projectEncrypted = "${project.getLatestVersionContent()}";
	var projectKey = "${project.idKey}";
	var vault = readVault();
	var decryptionKey = vault[projectKey];
	var projectJson = JSON.parse(decryptFromServer(decryptionKey.key, decryptionKey.iv, projectEncrypted));
	if(projectJson.remoteId == null) {
		projectJson.remoteId = ${project.id};
	}
	var project = prototypeProject(projectJson);
	project.saved = true;
	
	var projectVue = new Vue({
		el: '#editor',
		data: project,
		methods: {
			goTo: function(number) {
				window.location.href= "#chapter_" + number;
			},
			contentUpdate: function(chapter, scene, event) {
				this.saved = false;
				var previousLength = this.chapters[chapter - 1 ].content[scene].content.length;
				this.chapters[chapter - 1 ].content[scene].content = $(event.target).html().trim();
				if(previousLength == 0 && this.chapters[chapter - 1 ].content[scene].content.length == 0) {
					console.log(event.keyCode);
					if(event.keyCode == 8 || event.keyCode == 46) {
						var message = "&{'editor.messages.removescene.firstpart'} " + chapter + " &{'editor.messages.removescene.finalpart'}";
						var $this = this;
						askConfirmation(message, "&{'editor.messages.removescene.button'}").pipe(function() {
							$this.$data.chapters[chapter - 1].removeScene(scene + 1);
						});
					}
				}
			},
			pushToServer: function() {
				saveProjectVersion(this.$data);
				this.saved = true;
			},
			addChapter: function() {
				this.$data.addChapter();
			},
			removeChapter: function(chapter) {
				var message = "&{'editor.messages.removechapter.firstpart'} " + chapter + " &{'editor.messages.removechapter.secondpart'} " + this.chapters[chapter - 1].getWords() + " &{'editor.messages.removechapter.finalpart'}";
				var $this = this;
				askConfirmation(message, "&{'editor.messages.removechapter.button'}").pipe(function() {
					$this.$data.removeChapter(chapter);
				});
			},
			addScene: function(chapter) {
				this.chapters[chapter - 1].addScene();
			},
			renameChapter: function(chapter) {
				
			},
			getEpub: function() {
				var epub = new EpubBuilder(project);
				epub.build(function(result) {
					var clickEvent;
					var downloadButton = document.getElementById("download-epub");
					clickEvent = document.createEvent("MouseEvent");
					clickEvent.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
					downloadButton.href = URL.createObjectURL(result);
					downloadButton.download = project.name + ".epub";
					downloadButton.dispatchEvent(clickEvent);
				});
			}
		},
		ready: function() {
			if(this.$data.chapters.length == 1 && this.$data.chapters[0].content.length == 1) {
				focusOnEditableContent("chapter_1_scene_0", 0);
				this.$data.saved = true;
			}
		}
	});
	
	window.onbeforeunload = function (e) {
	    if(!project.saved) {
	    	e.returnValue="&{'editor.messages.warningnotsaved'}";
	    	return "&{'editor.messages.warningnotsaved'}";
	    }
	};
</script>